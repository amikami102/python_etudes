# unbreakable_encryption.py
"""
A script mimicking a one-time pad that encrypts data into a pair of keys and decrypts the keys to unlock the original data.

Note that we're using the big-Endianness order for encrypting/decrypting.
"""
from secrets import token_bytes
from typing import *
import math


def random_key(length: int) -> int:
    """Generate random bytes and convert it to a bit string."""
    tb: bytes = token_bytes(length)
    return int.from_bytes(tb, "big")


def encrypt(original: str) -> tuple[int, int]:
    """
    Encrypt `original` data with dummy data generated by `random_key()`.
    Return the pair of keys.
    """
    original_bytes: bytes = original.encode()

    dummy: int = random_key(len(original_bytes))
    
    # from_bytes() will convert `original_bytes` to 8bit/byte * len(original_bytes) bit integer
    original_key: int = int.from_bytes(original_bytes, "big")
    
    return dummy, original_key ^ dummy


def decrypt(key1: int, key2: int) -> str:
    """
    Decrypt by taking XOR product of the input keys and.
    Convert the integer to bytes and then to string to get the original data back.
    """
    decrypted: int = key1 ^ key2
    bit_length: int = (decrypted.bit_length() + 7) // 8
    return decrypted.to_bytes(bit_length, 'big').decode()


if __name__ == '__main__':
    
    data = 'One time pad!'
    print(f'Original data to be encrypted: {data!r}')
    
    keys = encrypt(data)
    result: str = decrypt(*keys)
    
    assert result == data
    print('We got the original data back')